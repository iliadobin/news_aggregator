# Эпик 7: Классический бот (Control-bot, aiogram v3) — управление фильтрами, источниками и доставкой

Дата: 2025‑12‑17

## Цель эпика

Реализовать классического Telegram‑бота (Bot API) как UI‑слой для пользователей:

- регистрация/привязка пользователя
- управление фильтрами (создание/удаление/вкл‑выкл/настройка ключевых слов и порога семантики)
- управление источниками (список доступных, подписка/отписка)
- настройка целевого чата/канала (куда доставлять новости)
- валидация пользовательского ввода + тесты на основные хендлеры с моками Telegram API

## Что сделано (high-level)

- Добавлен **control‑bot на aiogram v3** (long polling).
- Реализован **UI через inline‑клавиатуры** + FSM (для шагов, где пользователь вводит текст/числа).
- Подключено **хранилище (PostgreSQL через async SQLAlchemy)**: управление идёт через существующие репозитории
  (`UserRepository`, `FilterRepository`, `SourceRepository`, `SubscriptionRepository`).
- Добавлена **валидация**:
  - безопасный парсинг и проверка `chat_id`
  - парсинг ключевых слов (comma/newline) с удалением дублей
  - парсинг порога семантики (0.0–1.0, поддержка запятой)
  - строгие `CallbackData` для inline‑кнопок (чтобы не принимать произвольные callback‑строки)
- Добавлены **unit‑тесты** на ключевые сценарии хендлеров и на валидаторы.

## Новые файлы (Control-bot)

- `app/bots/control_bot/bot.py`
  - сборка `Bot` и `Dispatcher`
  - подключение роутеров
  - подключение middleware
- `app/bots/control_bot/runner.py`
  - запуск long polling
  - установка команд бота (`/start`, `/filters`, `/sources`, …)
- `app/bots/control_bot/middlewares.py`
  - middleware, которое на каждый апдейт открывает DB‑сессию и инжектит в хендлеры репозитории
- `app/bots/control_bot/handlers_settings.py`
  - `/start`, `/settings`, `/help`
  - меню “куда доставлять” (`target`)
  - установка target чата (на текущий чат или ввод chat_id)
- `app/bots/control_bot/handlers_filters.py`
  - `/filters`
  - список фильтров, создание фильтра, открытие, включение/выключение, удаление
  - редактирование ключевых слов и порога семантики (FSM)
- `app/bots/control_bot/handlers_sources.py`
  - `/sources`
  - список доступных источников из БД, подписка/отписка (inline‑кнопки), пагинация
- `app/bots/control_bot/keyboards.py`
  - inline‑клавиатуры меню/подменю
- `app/bots/control_bot/callbacks.py`
  - `CallbackData` схемы для callback’ов (`menu`, `flt`, `src`, `tgt`)
- `app/bots/control_bot/states.py`
  - FSM состояния для создания фильтра / редактирования / ввода target chat id
- `app/bots/control_bot/validation.py`
  - парсинг/валидация пользовательского ввода

## Команды и меню

### Регистрация/привязка пользователя

- `/start`
  - создаёт пользователя в таблице `users` через `UserRepository.get_or_create_by_telegram_id`
  - заполняет `username/first_name/last_name`
  - выставляет `is_admin`, если `telegram_id` входит в `BOT_ADMIN_IDS`
  - показывает главное меню (inline‑кнопки)
- `/settings`
  - показывает главное меню (повторный вход в UI)

### Управление фильтрами

- `/filters` → меню фильтров
- Inline‑функции:
  - **список фильтров** (включённые и выключенные)
  - **создать фильтр** (FSM: ввод названия)
  - **открыть фильтр** → карточка фильтра + действия:
    - включить/выключить (`is_active`)
    - удалить
    - отредактировать ключевые слова (FSM: ввод списка)
    - отредактировать порог семантики (FSM: ввод float 0.0–1.0)

Данные сохраняются в ORM‑модели `Filter`:

- `keywords`: JSON‑список строк
- `semantic_threshold`: float
- `is_active`: bool
- `mode`: сейчас остаётся дефолтным (в БД по умолчанию `combined`)

### Управление источниками

- `/sources` → меню источников
- Inline‑функции:
  - показать **список доступных активных источников** (`Source.is_active=True`)
  - **подписаться/отписаться** на источник (через `SubscriptionRepository`)
  - простая **пагинация** кнопками “⬅️/➡️”

Важно: “доступные источники” берутся из таблицы `sources`. Обычно она наполняется юзер‑ботом при чтении сообщений,
или может быть заполнена вручную/скриптом.

### Настройка целевого чата/канала

- `/target` → меню target
- `/set_target` → установить текущий чат как target (полезно в группе/канале)
- Inline‑функции:
  - показать текущий target
  - установить target на текущий чат
  - очистить target
  - “ввести chat_id” (FSM: пользователь присылает числовой id)

Данные сохраняются в `User.target_chat_id`.

## Валидация пользовательского ввода

Сделано так, чтобы бот принимал только ожидаемые форматы:

- **Callback‑валидация**:
  - все inline‑кнопки используют `CallbackData` (`callbacks.py`), что ограничивает формат callback‑строк
- **Текстовый ввод (FSM)**:
  - `parse_keywords()` — принимает “через запятую” и “с новой строки”, чистит пустые элементы, убирает дубли (case‑insensitive)
  - `parse_threshold()` — принимает float, поддерживает `0,7`, проверяет диапазон \[0.0, 1.0]
  - `parse_chat_id()` — принимает только числовой `chat_id` (в т.ч. отрицательный), `@username` пока не поддержан

## Интеграция с БД

Используется существующий слой `app/infra/db/*`:

- `DbSessionMiddleware` открывает `get_db_session()` на каждый апдейт и инжектит:
  - `session`
  - `user_repo`, `filter_repo`, `source_repo`, `subscription_repo`
- Репозитории используют async SQLAlchemy и коммитятся на выходе из `get_db_session()` (см. `DatabaseManager.session()`).

## Тесты

Добавлены unit‑тесты, которые не требуют реального Telegram API:

- `app/tests/unit/test_control_bot_validation.py`
  - тестирует `parse_keywords/parse_threshold/parse_chat_id`
- `app/tests/unit/test_control_bot_handlers.py`
  - тестирует ключевые хендлеры через `AsyncMock` и простые заглушки (`SimpleNamespace`)
  - кейсы:
    - `/start` регистрирует пользователя и показывает меню
    - создание фильтра (установка FSM состояния)
    - сохранение фильтра (вызов репозитория + очистка FSM)
    - подписка на источник (вызов репозитория)
    - установка FSM для ввода target chat id

Статус: все тесты проекта проходят (`pytest`).

## Запуск

```bash
python -m app.bots.control_bot.runner
```

## Конфигурация (env)

Используется `TelegramBotSettings` (`BOT_` префикс):

- `BOT_TOKEN` — токен control‑бота
- `BOT_ADMIN_IDS` — список id администраторов (через запятую или JSON‑массив)

## Ограничения текущей версии / что можно улучшить дальше

- **Темы (topics)** и **режим filter mode** (keyword_only/semantic_only/combined) пока не настраиваются из UI
  (создаваемые фильтры создаются с дефолтным `mode` и пустыми `topics`).
- Ввод target пока поддерживает **только числовой `chat_id`**, без `@username`/линков.
- UI источников отображает только то, что уже есть в `sources` (нет добавления источника по ссылке/username).
- Отдельная логика **forwarder/доставки** в Telegram (copy/forward в `target_chat_id`) находится вне этого эпика:
  control‑bot сохраняет настройки, а фактическую пересылку должен делать слой dispatcher/forwarder.

